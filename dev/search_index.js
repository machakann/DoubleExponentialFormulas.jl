var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Index-1","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [DoubleExponentialFormulas]\nOrder = [:function, :type]","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [DoubleExponentialFormulas]\nPrivate = false\nOrder = [:function, :type]","category":"page"},{"location":"reference/#DoubleExponentialFormulas.quadde-Tuple{Function,Real,Real,Vararg{Real,N} where N}","page":"Reference","title":"DoubleExponentialFormulas.quadde","text":"I, E = quadde(f::Function, a::Real, b::Real, c::Real...;\n              atol::Real=zero(Float64),\n              rtol::Real=atol>0 ? zero(Float64) : sqrt(eps(Float64)))\n\nNumerically integrate f(x) over an arbitrary interval [a, b] and return the integral value I and an estimated error E. The E is not exactly equal to the difference from the true value. However, one can expect that the integral value I is converged if E <= max(atol, rtol*norm(I)) is true. Otherwise, the obtained I would be unreliable; the number of repetitions exceeds the maxlevel before converged. Optionally, one can divide the integral interval [a, b, c...], which returns ∫ f(x)dx in [a, b] + ∫f(x)dx in [b, c[1]] + ⋯. It is worth noting that each endpoint allows discontinuity or singularity.\n\nThe integrand f can also return any value other than a scalar, as far as +, -, multiplication by real values, and LinearAlgebra.norm, are implemented. For example, Vector or Array of numbers are acceptable although, unfortunately, it may not be very performant.\n\nExamples\n\njulia> using DoubleExponentialFormulas\n\njulia> using LinearAlgebra: norm\n\njulia> f(x) = 2/(1 + x^2);\n\njulia> I, E = quadde(f, -1, 1);\n\njulia> I ≈ π\ntrue\n\njulia> E ≤ sqrt(eps(Float64))*norm(I)\ntrue\n\njulia> I, E = quadde(x -> [1/(1 + x^2), 2/(1 + x^2)], 0, Inf);\n\njulia> I ≈ [π/2, π]\ntrue\n\njulia> E ≤ sqrt(eps(Float64))*norm(I)\ntrue\n\njulia> I, E = quadde(x -> 1/sqrt(abs(x)), -1, 0, 1);  # singular point at x = 0\n\njulia> I ≈ 4\ntrue\n\njulia> E ≤ sqrt(eps(Float64))*norm(I)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#DoubleExponentialFormulas.QuadDE","page":"Reference","title":"DoubleExponentialFormulas.QuadDE","text":"QuadDE(T::Type{<:AbstractFloat}; maxlevel::Integer=10, h0::Real=one(T)/8)\n\nA callable object to integrate an function over an arbitrary interval, which uses the double exponential formulas also known as the tanh-sinh quadrature and its variants. It utilizes the change of variables to transform the integrand into a form well-suited to the trapezoidal rule.\n\nQuadDE tries to calculate integral values maxlevel times at a maximum; the step size of a trapezoid is started from h0 and is halved in each following repetition for finer accuracy. The repetition is terminated when the difference from the previous estimation gets smaller than a certain threshold. The threshold is determined by the runtime parameters, see below.\n\nThe type T represents the accuracy of interval. The integrand should accept values x<:T as its parameter.\n\n\n\nI, E = (q::QuadDE{T})(f::Function, a::Real, b::Real, c::Real...;\n                      atol::Real=zero(T),\n                      rtol::Real=atol>0 ? zero(T) : sqrt(eps(T)))\n                      where {T<:AbstractFloat}\n\nNumerically integrate f(x) over an arbitrary interval [a, b] and return the integral value I and an estimated error E. The E is not exactly equal to the difference from the true value. However, one can expect that the integral value I is converged if E <= max(atol, rtol*norm(I)) is true. Otherwise, the obtained I would be unreliable; the number of repetitions exceeds the maxlevel before converged. Optionally, one can divide the integral interval [a, b, c...], which returns ∫f(x)dx in [a, b] + ∫f(x)dx in [b, c[1]] + ⋯. It is worth noting that each endpoint allows discontinuity or singularity.\n\nThe integrand f can also return any value other than a scalar, as far as +, -, multiplication by real values, and LinearAlgebra.norm, are implemented. For example, Vector or Array of numbers are acceptable although, unfortunately, it may not be very performant.\n\nExamples\n\njulia> using DoubleExponentialFormulas\n\njulia> using LinearAlgebra: norm\n\njulia> qde = QuadDE(Float64);\n\njulia> f(x) = 2/(1 + x^2);\n\njulia> I, E = qde(f, -1, 1);\n\njulia> I ≈ π\ntrue\n\njulia> E ≤ sqrt(eps(Float64))*norm(I)\ntrue\n\njulia> g(x) = [1/(1 + x^2), 2/(1 + x^2)];\n\njulia> I, E = qde(g, 0, Inf);\n\njulia> I ≈ [π/2, π]\ntrue\n\njulia> E ≤ sqrt(eps(Float64))*norm(I)\ntrue\n\njulia> h(x) = 1/sqrt(abs(x));  # singular point at x = 0\n\njulia> I, E = qde(h, -1, 0, 1);\n\njulia> I ≈ 4\ntrue\n\njulia> E ≤ sqrt(eps(Float64))*norm(I)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/#DoubleExponentialFormulas.QuadES","page":"Reference","title":"DoubleExponentialFormulas.QuadES","text":"QuadES(T::Type{<:AbstractFloat}; maxlevel::Integer=10, h0::Real=one(T)/8)\n\nA callable object to integrate a function over the range [0, ∞) using the exp-sinh quadrature. It utilizes the change of variables to transform the integrand into a form well-suited to the trapezoidal rule.\n\nQuadES tries to calculate integral values maxlevel times at a maximum; the step size of a trapezoid is started from h0 and is halved in each following repetition for finer accuracy. The repetition is terminated when the difference from the previous estimation gets smaller than a certain threshold. The threshold is determined by the runtime parameters, see below.\n\nThe type T represents the accuracy of interval. The integrand should accept values x<:T as its parameter.\n\n\n\nI, E = (q::QuadES)(f::Function;\n                   atol::Real=zero(T),\n                   rtol::Real=atol>0 ? zero(T) : sqrt(eps(T)))\n                   where {T<:AbstractFloat}\n\nNumerically integrate f(x) over the interval [0, ∞) and return the integral value I and an estimated error E. The E is not exactly equal to the difference from the true value. However, one can expect that the integral value I is converged if E <= max(atol, rtol*norm(I)) is true. Otherwise, the obtained I would be unreliable; the number of repetitions exceeds the maxlevel before converged.\n\nThe integrand f can also return any value other than a scalar, as far as +, -, multiplication by real values, and LinearAlgebra.norm, are implemented. For example, Vector or Array of numbers are acceptable although, unfortunately, it may not be very performant.\n\nExamples\n\njulia> using DoubleExponentialFormulas\n\njulia> using LinearAlgebra: norm\n\njulia> qes = QuadES(Float64);\n\njulia> f(x) = 2/(1 + x^2);\n\njulia> I, E = qes(f);\n\njulia> I ≈ π\ntrue\n\njulia> E ≤ sqrt(eps(Float64))*norm(I)\ntrue\n\njulia> I, E = qes(x -> [1/(1 + x^2), 2/(1 + x^2)]);\n\njulia> I ≈ [π/2, π]\ntrue\n\njulia> E ≤ sqrt(eps(Float64))*norm(I)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/#DoubleExponentialFormulas.QuadSS","page":"Reference","title":"DoubleExponentialFormulas.QuadSS","text":"QuadSS(T::Type{<:AbstractFloat}; maxlevel::Integer=10, h0::Real=one(T)/8)\n\nA callable object to integrate a function over the range (-∞, ∞) using the sinh-sinh quadrature. It utilizes the change of variables to transform the integrand into a form well-suited to the trapezoidal rule.\n\nQuadSS tries to calculate integral values maxlevel times at a maximum; the step size of a trapezoid is started from h0 and is halved in each following repetition for finer accuracy. The repetition is terminated when the difference from the previous estimation gets smaller than a certain threshold. The threshold is determined by the runtime parameters, see below.\n\nThe type T represents the accuracy of interval. The integrand should accept values x<:T as its parameter.\n\n\n\nI, E = (q::QuadSS)(f::Function;\n                   atol::Real=zero(T),\n                   rtol::Real=atol>0 ? zero(T) : sqrt(eps(T)))\n                   where {T<:AbstractFloat}\n\nNumerically integrate f(x) over the interval (-∞, ∞) and return the integral value I and an estimated error E. The E is not exactly equal to the difference from the true value. However, one can expect that the integral value I is converged if E <= max(atol, rtol*norm(I)) is true. Otherwise, the obtained I would be unreliable; the number of repetitions exceeds the maxlevel before converged.\n\nThe integrand f can also return any value other than a scalar, as far as +, -, multiplication by real values, and LinearAlgebra.norm, are implemented. For example, Vector or Array of numbers are acceptable although, unfortunately, it may not be very performant.\n\nExamples\n\njulia> using DoubleExponentialFormulas\n\njulia> using LinearAlgebra: norm\n\njulia> qss = QuadSS(Float64);\n\njulia> f(x) = 2/(1 + x^2);\n\njulia> I, E = qss(f);\n\njulia> I ≈ 2π\ntrue\n\njulia> E ≤ sqrt(eps(Float64))*norm(I)\ntrue\n\njulia> I, E = qss(x -> [1/(1 + x^2), 2/(1 + x^2)]);\n\njulia> I ≈ [π, 2π]\ntrue\n\njulia> E ≤ sqrt(eps(Float64))*norm(I)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/#DoubleExponentialFormulas.QuadTS","page":"Reference","title":"DoubleExponentialFormulas.QuadTS","text":"QuadTS(T::Type{<:AbstractFloat}; maxlevel::Integer=10, h0::Real=one(T)/8)\n\nA callable object to integrate a function over the range [-1, 1] using the tanh-sinh quadrature. It utilizes the change of variables to transform the integrand into a form well-suited to the trapezoidal rule.\n\nQuadTS tries to calculate integral values maxlevel times at a maximum; the step size of a trapezoid is started from h0 and is halved in each following repetition for finer accuracy. The repetition is terminated when the difference from the previous estimation gets smaller than a certain threshold. The threshold is determined by the runtime parameters, see below.\n\nThe type T represents the accuracy of interval. The integrand should accept values x<:T as its parameter.\n\n\n\nI, E = (q::QuadTS)(f::Function;\n                   atol::Real=zero(T),\n                   rtol::Real=atol>0 ? zero(T) : sqrt(eps(T)))\n                   where {T<:AbstractFloat}\n\nNumerically integrate f(x) over the interval [-1, 1] and return the integral value I and an estimated error E. The E is not exactly equal to the difference from the true value. However, one can expect that the integral value I is converged if E <= max(atol, rtol*norm(I)) is true. Otherwise, the obtained I would be unreliable; the number of repetitions exceeds the maxlevel before converged.\n\nThe integrand f can also return any value other than a scalar, as far as +, -, multiplication by real values, and LinearAlgebra.norm, are implemented. For example, Vector or Array of numbers are acceptable although, unfortunately, it may not be very performant.\n\nExamples\n\njulia> using DoubleExponentialFormulas\n\njulia> using LinearAlgebra: norm\n\njulia> qts = QuadTS(Float64);\n\njulia> f(x) = 2/(1 + x^2);\n\njulia> I, E = qts(f);\n\njulia> I ≈ π\ntrue\n\njulia> E ≤ sqrt(eps(Float64))*norm(I)\ntrue\n\njulia> I, E = qts(x -> [1/(1 + x^2), 2/(1 + x^2)]);\n\njulia> I ≈ [π/2, π]\ntrue\n\njulia> E ≤ sqrt(eps(Float64))*norm(I)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#DoubleExponentialFormulas.jl-1","page":"Home","title":"DoubleExponentialFormulas.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package provides functions for one-dimensional numerical integration using the double exponential formula [1][2] also known as the tanh-sinh quadrature and its variants.","category":"page"},{"location":"#Theory-1","page":"Home","title":"Theory","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The double exponential formulas transform an integrand into another form well-suited to the trapezoidal rule. For example, the tanh-sinh quadrature converts an integration of f(x) on x over -1 1 into an equivalent integration on t over - ,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"int_-1^1 f(x) dx = int_-infty^infty fleft(x(t)right) fracdxdt dt = int_-infty^infty fleft(x(t)right)w(t) dt","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where","category":"page"},{"location":"#","page":"Home","title":"Home","text":"x(t) = tanh left( fracπ2 sinh t right) \nw(t) = fracfracπ2 cosh tcosh^2left(fracπ2 sinh t right)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Since fleft(x(t)right)w(t) rapidly decays with t increasing, the transformed integral is highly insensitive to both edges of the integral interval. Therefore, the infinite interval can be cut off at a certain (finite) point, and the numerical integration just works even if the integrand f(x) has singularity or discontinuity at the endpoints. For instance, generally, it is difficult to estimate the following integral because of the singularity at the endpoints.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"int_-1^1 f(x) dx = int_-1^1 fracdx(2-x)(1-x)^14(1+x)^34","category":"page"},{"location":"#","page":"Home","title":"Home","text":"However, the transformed integrand fleft(x(t)right)w(t) quickly drops and almost vanishes at t approx 4. The endpoint singularity has gone, and the range t  4 doesn't have any significant contribution.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: Change of variable)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This transformation accelerates the convergence and enhances the accuracy in a numerical integration; typically, the trapezoidal rule is used. The last integral is approximated to a weighted sum with a step size h,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"int_-infty^infty fleft(x(t)right)w(t) dt approx hsum_k = -infty^infty f(x_k)w_k","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where x_k = x(kh) and w_k = w(kh). The infinite summation is terminated if f(x_k)w_k gets small enough.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Another point is that the x_k and w_k is independent of integrands. Therefore, the table of these numbers can be pre-calculated and is re-usable. This mechanism significantly cut down the computational time.","category":"page"},{"location":"#Tanh-sinh-quadrature-1","page":"Home","title":"Tanh-sinh quadrature","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The tanh-sinh quadrature covers the numerical integrations over the range -1 1 using the following abscissas and weights.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"x(t) = tanh left( fracπ2 sinh t right) \nw(t) = fracfracπ2 cosh tcosh^2left(fracπ2 sinh t right)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Furthermore, the additional change of variables extends to the integration with arbitrary finite intervals a b.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"x(u) = fracb + a2 + fracb - a2u","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The x(u) changes from a to b when u changes from -1 to 1. Hence,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"int_a^b f(x) dx = int_-1^1 fleft(x(u)right)(b - a) du = int_-infty^infty fleft(xleft(u(t)right)right)(b - a)w(t) dt","category":"page"},{"location":"#Exp-sinh-quadrature-1","page":"Home","title":"Exp-sinh quadrature","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The exp-sinh quadrature is available for the numerical integration over the half-infinite interval 0 infty).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"x(t) = exp left( fracπ2 sinh t right) \nw(t) = fracπ2 cosh t expleft(fracπ2 sinh t right)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finite shift of the integral interval x(u) = u + a immediately enables integrating over a infty).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"int_a^infty f(x) dx = int_0^infty fleft(x(u)right) du = int_-infty^infty fleft(xleft(u(t)right)right)w(t) dt","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Similarly, reversing the abscissas around the origin x(u) = -u converts the integration on x over (-infty b into an equivalent integral on u over -b infty).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"int_-infty^b f(x) dx = int_-b^infty fleft(x(u)right) du","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that int_a^b f(x) dx = -int_b^a f(x) dx. In conclusion, the exp-sinh quadrature covers arbitrary half-infinite integral intervals, a infty) and (-infty b.","category":"page"},{"location":"#Sinh-sinh-quadrature-1","page":"Home","title":"Sinh-sinh quadrature","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The sinh-sinh quadrature covers the infinite integral interval (-infty infty).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"x(t) = sinh left( fracπ2 sinh t right) \nw(t) = fracπ2 cosh t coshleft(fracπ2 sinh t right)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The transformation doesn't change the interval. However, fleft(x(t)right)w(t) decays quickly in the t space, as far as the integral isn't divergent, to make the numerical integration quite efficient.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"int_-infty^infty f(x) dx = int_-infty^infty fleft(x(t)right)w(t) dt","category":"page"},{"location":"#Instllation-1","page":"Home","title":"Instllation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Press ] on a Julia REPL to enter the Pkg mode, and run the following command.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"add https://github.com/machakann/DoubleExponentialFormulas.jl.git","category":"page"},{"location":"#Usage-1","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#Handy-interface-in-Float64-precision-1","page":"Home","title":"Handy interface in Float64 precision","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"    I, E = quadde(f::Function, a::Real, b::Real, c::Real...;\n                  atol::Real=zero(Float64),\n                  rtol::Real=atol>0 ? zero(Float64) : sqrt(eps(Float64)))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The quadde function provides a handy way to integrate a function f(x) in an arbitrary interval.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using DoubleExponentialFormulas\nusing LinearAlgebra: norm\n\nf(x) = 1/(1 + x^2)\nI, E = quadde(f, -1, 1)\n\nI ≈ π/2                   # true\nE ≤ sqrt(eps(I))*norm(I)  # true","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The above example computes int_-1^1 frac11 + x^2 dx. The I is the obtained integral value and the E is an estimated numerical error. The E is not exactly equal to the difference from the true value. However, one can expect that the integral value I is converged if E <= max(atol, rtol*norm(I)) is true. Otherwise, the obtained I would be unreliable; the number of repetitions exceeds the maxlevel before converged.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Half-infinite intervals, a infty) and (-infty b, and the infinite interval, (infty -infty), are also valid as far as the integral is convergent.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# Computes ∫ 1/(1+x^2) dx in [0, ∞)\nI, E = quadde(x -> 1/(1 + x^2), 0, Inf)\nI ≈ π/2    # true\n\n# Computes ∫ 1/(1+x^2) dx in (-∞, ∞)\nI, E = quadde(x -> 1/(1 + x^2), -Inf, Inf)\nI ≈ π      # true","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: Fig.1-3)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Optionally, one can subdivide the integral interval [a, b, c, ...], which returns int_a^b f(x) dx + int_b^c f(x) dx + cdots.  It is worth noting that discontinuity or singularity is allowed at the endpoints.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# Computes ∫ 1/sqrt(|x|) dx in (-∞, ∞)\n# The integrand has a singular point at x = 0\nI, E = quadde(x -> 1/sqrt(abs(x)), -1, 0, 1)\nI ≈ 4    # true","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: Fig.4)","category":"page"},{"location":"#Optimized-numerical-integrators-1","page":"Home","title":"Optimized numerical integrators","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The type QuadDE represents the pre-calculated table of x_k and w_k. If one needs an optimized table, for example with a smaller step size h or with a better precision using BigFloat, QuadDE will provides the functionality.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"qde = QuadDE(BigFloat; h0=one(BigFloat)/8, maxlevel=10)\nqde(x -> 2/(1 + x^2), -1,  1)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"User can specify the required precision as a type (T<:AbstractFloat), the starting step size h0 and the maximum number of repetition maxlevel. The h0 and maxlevel shown above are the default values, so it can be omitted. QuadDE instance is an callable object which has the same interface of quadde, actually quadde is an alias to QuadDE(Float64)(...) with a pre-calculated instance.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"QuadTS tries to calculate integral values maxlevel times at a maximum; the step size of a trapezoid is started from h0 and is halved in each following repetition for finer accuracy. The repetition is terminated when the difference from the previous estimation gets smaller than a certain threshold.  The threshold is determined by the runtime parameters, atol or rtol.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Using smaller h0 may help if the integrand f(x) includes fine structure, such as spikes, in the integral interval. However, the subdivision of the interval would be more effective in many cases. Try subdivision first, and then think of an optimized integrator.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[1]: Takahasi, H.; Mori, M. Double Exponential Formulas for Numerical Integration. Publ. Res. Inst. Math. Sci. 1973, 9 (3), 721–741.  https://doi.org/10.2977/prims/1195192451.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[2]: Mori, M.; Sugihara, M. The Double-Exponential Transformation in Numerical Analysis. J. Comput. Appl. Math. 2001, 127 (1–2), 287–296.  https://doi.org/10.1016/S0377-0427(00)00501-X.","category":"page"}]
}
